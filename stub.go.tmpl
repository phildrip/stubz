package {{.PackageName}}

import (
    "sync"
)

type {{.StubName}}Call struct {
    {{range .Methods}}
    {{.Name}}Calls []struct {
        {{range .Params}}
        {{.Name}} {{.Type}}
        {{end}}
    }
    {{end}}
}

type {{.StubName}} struct {
    mu sync.Mutex
    calls {{.StubName}}Call
    {{range .Methods}}
    {{.Name}}Func func({{range $index, $param := .Params}}{{if $index}}, {{end}}{{$param.Name}} {{$param.Type}}{{end}}) {{if .Results}}{{.Results}}{{else}}error{{end}}
    {{end}}
}

func (s *{{.StubName}}) On() *{{.StubName}} {
    return s
}

{{range .Methods}}
func (s *{{$.StubName}}) {{.Name}}({{range $index, $param := .Params}}{{if $index}}, {{end}}{{$param.Name}} {{$param.Type}}{{end}}) {{if .Results}}({{range $index, $result := .Results}}{{if $index}}, {{end}}{{$result.Type}}{{end}}){{end}} {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.calls.{{.Name}}Calls = append(s.calls.{{.Name}}Calls, struct{ {{range .Params}}{{.Name}} {{.Type}}; {{end}} }{ {{range .Params}}{{.Name}}: {{.Name}}, {{end}} })
    if s.{{.Name}}Func != nil {
        return s.{{.Name}}Func({{range $index, $param := .Params}}{{if $index}}, {{end}}{{$param.Name}}{{end}})
    }
    {{if .Results}}
    var zero {{.Results}}
    return zero
    {{else}}
    return nil
    {{end}}
}

func (s *{{$.StubName}}) {{.Name}}ThenReturn({{if .Results}}{{range $index, $result := .Results}}{{if $index}}, {{end}}{{$result.Type}}{{$index}} {{$result.Type}}{{end}}{{end}}) *{{$.StubName}} {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.{{.Name}}Func = func({{range $index, $param := .Params}}{{if $index}}, {{end}}{{$param.Name}} {{$param.Type}}{{end}}) {{if .Results}}{{.Results}}{{else}}error{{end}} {
        return {{if .Results}}{{.ResultNames}}{{else}}err{{end}}
    }
    return s
}

func (s *{{$.StubName}}) {{.Name}}Calls() []struct{ {{range .Params}}{{.Name}} {{.Type}}; {{end}} } {
    s.mu.Lock()
    defer s.mu.Unlock()
    return s.calls.{{.Name}}Calls
}
{{end}}
